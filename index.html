export default {
  async fetch(request, env) {
    // ------------------ ENV ------------------
    const BIN_ID = env.BIN_ID;
    const KEY = env.MASTER_KEY;

    // Admin for management actions
    const ADMIN_PIN = env.ADMIN_PIN;

    // Invite code required every time to create player profiles
    const CREATE_PROFILE_PIN = env.CREATE_PROFILE_PIN;

    // Invite code required to create teams (you said 6969)
    const TEAM_INVITE_PIN = env.TEAM_INVITE_PIN || "6969";

    // Active season default
    const DEFAULT_SEASON_ID = env.DEFAULT_SEASON_ID || "2026";

    if (!BIN_ID || !KEY) {
      return new Response("Missing BIN_ID or MASTER_KEY", { status: 500 });
    }

    const base = `https://api.jsonbin.io/v3/b/${BIN_ID}`;
    const cors = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET,POST,PUT,DELETE,OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization"
    };

    if (request.method === "OPTIONS") return new Response(null, { headers: cors });

    const url = new URL(request.url);
    const path = url.pathname.replace(/\/+$/, "") || "/";
    const q = url.searchParams;

    // ------------------ helpers ------------------
    const json = (obj, status = 200) =>
      new Response(JSON.stringify(obj), {
        status,
        headers: { ...cors, "Content-Type": "application/json" }
      });

    const text = (msg, status = 200) =>
      new Response(msg, { status, headers: { ...cors, "Content-Type": "text/plain" } });

    async function sha256Hex(str) {
      const bytes = new TextEncoder().encode(str);
      const digest = await crypto.subtle.digest("SHA-256", bytes);
      return Array.from(new Uint8Array(digest))
        .map((b) => b.toString(16).padStart(2, "0"))
        .join("");
    }

    function nowIso() {
      return new Date().toISOString();
    }

    function keyName(name) {
      return (name || "").trim().toLowerCase();
    }

    function cleanName(name) {
      return (name || "").trim();
    }

    function isValidPin(pin) {
      return /^[0-9]{4,8}$/.test((pin || "").trim());
    }

    function isValidPhase(phase) {
      return ["preseason", "regular", "championship", "unranked"].includes(phase);
    }

    function isValidGameType(gt) {
      return ["doubles", "singles"].includes(gt);
    }

    function dedupe(arr) {
      return Array.from(new Set(arr));
    }

    function sortKeys(arr) {
      return [...arr].sort((a, b) => a.localeCompare(b));
    }

    function teamIdFor(memberKeys2) {
      // canonical 2-person team id: t_<a>_<b> sorted
      const [a, b] = sortKeys(memberKeys2);
      return `t_${a}_${b}`;
    }

    function getBearerToken(req) {
      const h = req.headers.get("Authorization") || "";
      const m = h.match(/^Bearer\s+(.+)$/i);
      return m ? m[1].trim() : "";
    }

    async function readRawRecord() {
      const r = await fetch(`${base}/latest`, { headers: { "X-Master-Key": KEY } });
      const j = await r.json();
      return j?.record ?? {};
    }

    async function writeRawRecord(record) {
      await fetch(base, {
        method: "PUT",
        headers: { "Content-Type": "application/json", "X-Master-Key": KEY },
        body: JSON.stringify(record)
      });
    }

    async function readState() {
      const record = await readRawRecord();

      // ---- normalize / migrate ----
      const state = {
        version: typeof record.version === "number" ? record.version : 1,

        league: record.league && typeof record.league === "object"
          ? record.league
          : {
              activeSeasonId: DEFAULT_SEASON_ID,
              seasons: {
                [DEFAULT_SEASON_ID]: { name: `${DEFAULT_SEASON_ID} Season`, createdAt: nowIso() }
              }
            },

        matches: Array.isArray(record.matches) ? record.matches : [],
        players: record.players && typeof record.players === "object" ? record.players : {},
        teams: record.teams && typeof record.teams === "object" ? record.teams : {},
        devices: record.devices && typeof record.devices === "object" ? record.devices : {}
      };

      // ensure active season exists
      if (!state.league.activeSeasonId) state.league.activeSeasonId = DEFAULT_SEASON_ID;
      if (!state.league.seasons || typeof state.league.seasons !== "object") state.league.seasons = {};
      if (!state.league.seasons[state.league.activeSeasonId]) {
        state.league.seasons[state.league.activeSeasonId] = {
          name: `${state.league.activeSeasonId} Season`,
          createdAt: nowIso()
        };
      }

      // bootstrap Admin player if empty and ADMIN_PIN exists
      if (ADMIN_PIN && Object.keys(state.players).length === 0) {
        const k = "admin";
        const pinHash = await sha256Hex(`${k}:${ADMIN_PIN}`);
        state.players[k] = {
          name: "Admin",
          pinHash,
          isAdmin: true,
          createdAt: nowIso(),
          teamIds: [],
          defaultTeamId: null
        };
      }

      // migrate old matches shape (best-effort)
      for (const m of state.matches) {
        if (!m.seasonId) m.seasonId = state.league.activeSeasonId || DEFAULT_SEASON_ID;
        if (!m.phase) m.phase = "regular";
        if (typeof m.ranked !== "boolean") m.ranked = true;
        if (!m.gameType) m.gameType = "doubles";
        if (!m.recordedByKey && m.recordedBy) m.recordedByKey = keyName(m.recordedBy);
        if (!m.teamA?.members && Array.isArray(m.teamA?.players)) m.teamA.members = m.teamA.players.map(cleanName);
        if (!m.teamB?.members && Array.isArray(m.teamB?.players)) m.teamB.members = m.teamB.players.map(cleanName);
      }

      state.version = 3;
      return state;
    }

    async function writeState(state) {
      const record = {
        version: 3,
        league: state.league,
        matches: state.matches,
        players: state.players,
        teams: state.teams,
        devices: state.devices
      };
      await writeRawRecord(record);
    }

    async function requireAuth(state, req) {
      const token = getBearerToken(req);
      if (!token) return { ok: false, error: "Missing token" };

      const tokenHash = await sha256Hex(token);
      const device = state.devices[tokenHash];
      if (!device) return { ok: false, error: "Invalid token" };

      const player = state.players[device.playerKey];
      if (!player) return { ok: false, error: "Player not found" };

      return { ok: true, tokenHash, playerKey: device.playerKey, player };
    }

    function scrubPlayerPublic(k, p) {
      return {
        key: k,
        name: p.name,
        isAdmin: !!p.isAdmin,
        teamIds: Array.isArray(p.teamIds) ? p.teamIds : [],
        defaultTeamId: p.defaultTeamId || null,
        createdAt: p.createdAt || null
      };
    }

    function scrubTeamPublic(t) {
      return {
        id: t.id,
        name: t.name,
        members: t.members,
        createdAt: t.createdAt || null,
        createdByKey: t.createdByKey || null,
        bio: t.bio || "",
        homeCourt: t.homeCourt || "",
        color: t.color || ""
      };
    }

    function timeBucketIso(iso, minutes = 10) {
      const ms = new Date(iso).getTime();
      const bucketMs = minutes * 60 * 1000;
      return Math.floor(ms / bucketMs);
    }

    async function computeFingerprint(matchLike) {
      const seasonId = matchLike.seasonId || DEFAULT_SEASON_ID;
      const phase = matchLike.phase || "unranked";
      const ranked = !!matchLike.ranked;
      const gameType = matchLike.gameType || "doubles";

      const aMembers = sortKeys((matchLike.teamA?.members || []).map(keyName)).join(",");
      const bMembers = sortKeys((matchLike.teamB?.members || []).map(keyName)).join(",");

      const scoreA = Number(matchLike.teamA?.score);
      const scoreB = Number(matchLike.teamB?.score);

      const dt = matchLike.dateTime || nowIso();
      const bucket = timeBucketIso(dt, 10);

      const payload = `${seasonId}|${phase}|${ranked ? 1 : 0}|${gameType}|A:${aMembers}|B:${bMembers}|S:${scoreA}-${scoreB}|T:${bucket}`;
      return await sha256Hex(payload);
    }

    function assertMembersExist(state, memberKeys) {
      for (const k of memberKeys) {
        if (!state.players[k]) return { ok: false, error: `Unknown player: ${k}` };
      }
      return { ok: true };
    }

    // ------------------ ROUTES ------------------

    // Back-compat: GET / returns matches
    if (request.method === "GET" && path === "/") {
      const state = await readState();
      return json(state.matches);
    }

    // List players (public)
    if (request.method === "GET" && path === "/players") {
      const state = await readState();
      const list = Object.entries(state.players)
        .map(([k, p]) => scrubPlayerPublic(k, p))
        .sort((a, b) => a.name.localeCompare(b.name));
      return json({ players: list, activeSeasonId: state.league.activeSeasonId });
    }

    // Auth: PIN login -> token
    if (request.method === "POST" && path === "/auth/pin") {
      const state = await readState();
      let body;
      try { body = await request.json(); } catch { return json({ error: "Invalid JSON" }, 400); }

      const name = cleanName(body?.name);
      const pin = (body?.pin || "").trim();
      if (!name || !pin) return json({ error: "name and pin required" }, 400);

      const k = keyName(name);
      const player = state.players[k];
      if (!player) return json({ error: "Unknown player" }, 404);

      const attempt = await sha256Hex(`${k}:${pin}`);
      if (attempt !== player.pinHash) return json({ error: "Incorrect PIN" }, 401);

      const token = crypto.randomUUID ? crypto.randomUUID() : `${Date.now()}-${Math.random()}`;
      const tokenHash = await sha256Hex(token);

      state.devices[tokenHash] = { playerKey: k, createdAt: nowIso() };
      await writeState(state);

      return json({ token, player: scrubPlayerPublic(k, player) });
    }

    // Profile creation (invite code required every time)
    // POST /profile/create { createPin, name, pin }
    if (request.method === "POST" && path === "/profile/create") {
      if (!CREATE_PROFILE_PIN) return json({ error: "CREATE_PROFILE_PIN not configured" }, 500);

      const state = await readState();
      let body;
      try { body = await request.json(); } catch { return json({ error: "Invalid JSON" }, 400); }

      const createPin = (body?.createPin || "").trim();
      const name = cleanName(body?.name);
      const pin = (body?.pin || "").trim();

      if (createPin !== CREATE_PROFILE_PIN) return json({ error: "Invalid invite code" }, 403);
      if (!name || !pin) return json({ error: "name and pin required" }, 400);
      if (!isValidPin(pin)) return json({ error: "PIN must be 4–8 digits" }, 400);

      const k = keyName(name);
      if (!k) return json({ error: "Invalid name" }, 400);
      if (state.players[k]) return json({ error: "Player already exists" }, 409);

      state.players[k] = {
        name,
        pinHash: await sha256Hex(`${k}:${pin}`),
        isAdmin: false,
        createdAt: nowIso(),
        teamIds: [],
        defaultTeamId: null
      };

      await writeState(state);
      return json({ ok: true });
    }

    // Admin: manage players
    // POST /admin/player { adminPin, action: reset|remove|setAdmin, name, newPin?, makeAdmin? }
    if (request.method === "POST" && path === "/admin/player") {
      if (!ADMIN_PIN) return json({ error: "ADMIN_PIN not configured" }, 500);

      let body;
      try { body = await request.json(); } catch { return json({ error: "Invalid JSON" }, 400); }

      const pin = (body?.adminPin || "").trim();
      if (pin !== ADMIN_PIN) return json({ error: "Forbidden" }, 403);

      const state = await readState();
      const action = (body?.action || "").trim();
      const name = cleanName(body?.name);
      const k = keyName(name);

      if (!action || !name) return json({ error: "action and name required" }, 400);
      if (!state.players[k]) return json({ error: "Player not found" }, 404);

      if (action === "reset") {
        const newPin = (body?.newPin || "").trim();
        if (!isValidPin(newPin)) return json({ error: "newPin must be 4–8 digits" }, 400);
        state.players[k].pinHash = await sha256Hex(`${k}:${newPin}`);
        await writeState(state);
        return json({ ok: true });
      }

      if (action === "setAdmin") {
        const makeAdmin = !!body?.makeAdmin;
        state.players[k].isAdmin = makeAdmin;
        await writeState(state);
        return json({ ok: true });
      }

      if (action === "remove") {
        if (state.players[k].isAdmin) return json({ error: "Cannot remove admin player" }, 400);

        for (const [tid, t] of Object.entries(state.teams)) {
          if (Array.isArray(t.members) && t.members.includes(k)) {
            delete state.teams[tid];
          }
        }

        for (const pk of Object.keys(state.players)) {
          const p = state.players[pk];
          if (!Array.isArray(p.teamIds)) p.teamIds = [];
          p.teamIds = p.teamIds.filter((tid) => state.teams[tid]);
          if (p.defaultTeamId && !state.teams[p.defaultTeamId]) p.defaultTeamId = null;
        }

        for (const [th, d] of Object.entries(state.devices)) {
          if (d.playerKey === k) delete state.devices[th];
        }

        delete state.players[k];
        await writeState(state);
        return json({ ok: true });
      }

      return json({ error: "Unknown action" }, 400);
    }

    // Teams: list (GET /teams, GET /teams?mine=1)
    if (request.method === "GET" && path === "/teams") {
      const state = await readState();

      const mine = q.get("mine") === "1";
      if (!mine) {
        const list = Object.values(state.teams)
          .map(scrubTeamPublic)
          .sort((a, b) => (a.name || "").localeCompare(b.name || ""));
        return json({ teams: list });
      }

      const auth = await requireAuth(state, request);
      if (!auth.ok) return json({ error: auth.error }, 401);

      const list = Object.values(state.teams)
        .filter((t) => Array.isArray(t.members) && t.members.includes(auth.playerKey))
        .map(scrubTeamPublic)
        .sort((a, b) => (a.name || "").localeCompare(b.name || ""));
      return json({ teams: list });
    }

    // Teams: get by id
    const getTeam = path.match(/^\/teams\/([^/]+)$/);
    if (request.method === "GET" && getTeam) {
      const teamId = getTeam[1];
      const state = await readState();
      const t = state.teams[teamId];
      if (!t) return json({ error: "Team not found" }, 404);
      return json({ team: scrubTeamPublic(t) });
    }

    // Teams: create (auth + invite code + creator must be member)
    // POST /teams { inviteCode, members:[k1,k2], name? }
    if (request.method === "POST" && path === "/teams") {
      const state = await readState();
      const auth = await requireAuth(state, request);
      if (!auth.ok) return json({ error: auth.error }, 401);

      let body;
      try { body = await request.json(); } catch { return json({ error: "Invalid JSON" }, 400); }

      const inviteCode = (body?.inviteCode || "").trim();
      if (inviteCode !== TEAM_INVITE_PIN) return json({ error: "Invalid team invite code" }, 403);

      const membersRaw = Array.isArray(body?.members) ? body.members : [];
      const members = dedupe(membersRaw.map(keyName)).filter(Boolean);

      if (members.length !== 2) return json({ error: "Teams must have exactly 2 unique players" }, 400);
      if (!members.includes(auth.playerKey)) return json({ error: "You must be on the team you create" }, 403);

      const existsCheck = assertMembersExist(state, members);
      if (!existsCheck.ok) return json({ error: existsCheck.error }, 400);

      const id = teamIdFor(members);
      if (state.teams[id]) return json({ error: "That team already exists" }, 409);

      const p1 = state.players[members[0]].name;
      const p2 = state.players[members[1]].name;
      const defaultName = `${[p1, p2].sort((a, b) => a.localeCompare(b)).join(" + ")}`;
      const name = cleanName(body?.name) || defaultName;

      state.teams[id] = {
        id,
        name,
        members: sortKeys(members),
        createdAt: nowIso(),
        createdByKey: auth.playerKey,
        bio: "",
        homeCourt: "",
        color: ""
      };

      for (const mk of state.teams[id].members) {
        const p = state.players[mk];
        if (!Array.isArray(p.teamIds)) p.teamIds = [];
        if (!p.teamIds.includes(id)) p.teamIds.push(id);
        if (!p.defaultTeamId) p.defaultTeamId = id;
      }

      await writeState(state);
      return json({ ok: true, team: scrubTeamPublic(state.teams[id]) });
    }

    // Teams: update info (auth + must be team member)
    // PUT /teams/:id { name?, bio?, homeCourt?, color? }
    const putTeam = path.match(/^\/teams\/([^/]+)$/);
    if (request.method === "PUT" && putTeam) {
      const teamId = putTeam[1];
      const state = await readState();
      const auth = await requireAuth(state, request);
      if (!auth.ok) return json({ error: auth.error }, 401);

      const t = state.teams[teamId];
      if (!t) return json({ error: "Team not found" }, 404);

      if (!Array.isArray(t.members) || !t.members.includes(auth.playerKey)) {
        return json({ error: "Only team members can edit team info" }, 403);
      }

      let body;
      try { body = await request.json(); } catch { return json({ error: "Invalid JSON" }, 400); }

      const name = body?.name !== undefined ? cleanName(body.name) : undefined;
      const bio = body?.bio !== undefined ? String(body.bio || "") : undefined;
      const homeCourt = body?.homeCourt !== undefined ? String(body.homeCourt || "") : undefined;
      const color = body?.color !== undefined ? String(body.color || "") : undefined;

      if (name !== undefined) {
        if (!name) return json({ error: "Team name cannot be blank" }, 400);
        t.name = name;
      }
      if (bio !== undefined) t.bio = bio.slice(0, 2000);
      if (homeCourt !== undefined) t.homeCourt = homeCourt.slice(0, 200);
      if (color !== undefined) t.color = color.slice(0, 40);

      await writeState(state);
      return json({ ok: true, team: scrubTeamPublic(t) });
    }

    // Player: set default team (auth)
    // PUT /players/me { defaultTeamId }
    if (request.method === "PUT" && path === "/players/me") {
      const state = await readState();
      const auth = await requireAuth(state, request);
      if (!auth.ok) return json({ error: auth.error }, 401);

      let body;
      try { body = await request.json(); } catch { return json({ error: "Invalid JSON" }, 400); }

      const defaultTeamId = String(body?.defaultTeamId || "").trim();
      if (!defaultTeamId) return json({ error: "defaultTeamId required" }, 400);

      const t = state.teams[defaultTeamId];
      if (!t) return json({ error: "Team not found" }, 404);
      if (!Array.isArray(t.members) || !t.members.includes(auth.playerKey)) {
        return json({ error: "You can only set a default team you belong to" }, 403);
      }

      auth.player.defaultTeamId = defaultTeamId;
      await writeState(state);
      return json({ ok: true, player: scrubPlayerPublic(auth.playerKey, auth.player) });
    }

    // Matches: list with filters
    // GET /matches?seasonId=2026&phase=regular&ranked=1&gameType=doubles
    if (request.method === "GET" && path === "/matches") {
      const state = await readState();
      let matches = state.matches;

      const seasonId = q.get("seasonId");
      const phase = q.get("phase");
      const ranked = q.get("ranked");
      const gameType = q.get("gameType");

      if (seasonId) matches = matches.filter((m) => String(m.seasonId || "") === seasonId);
      if (phase) matches = matches.filter((m) => String(m.phase || "") === phase);
      if (ranked === "1") matches = matches.filter((m) => !!m.ranked);
      if (ranked === "0") matches = matches.filter((m) => !m.ranked);
      if (gameType) matches = matches.filter((m) => String(m.gameType || "") === gameType);

      return json(matches);
    }

    // Matches: create (auth required)
    // POST /matches
    if (request.method === "POST" && path === "/matches") {
      const state = await readState();
      const auth = await requireAuth(state, request);
      if (!auth.ok) return json({ error: auth.error }, 401);

      let body;
      try { body = await request.json(); } catch { return json({ error: "Invalid JSON" }, 400); }

      const seasonId = String(body?.seasonId || state.league.activeSeasonId || DEFAULT_SEASON_ID).trim();
      const phase = String(body?.phase || "unranked").trim();
      const ranked = !!body?.ranked;
      const gameType = String(body?.gameType || "doubles").trim();

      if (!seasonId) return json({ error: "seasonId required" }, 400);
      if (!isValidPhase(phase)) return json({ error: "Invalid phase" }, 400);
      if (!isValidGameType(gameType)) return json({ error: "Invalid gameType" }, 400);

      // enforce: singles must be unranked only
      if (gameType === "singles") {
        if (ranked) return json({ error: "Singles matches must be unranked" }, 400);
        if (phase !== "unranked") return json({ error: "Singles matches must use phase=unranked" }, 400);
      }

      const scoreA = Number(body?.teamA?.score);
      const scoreB = Number(body?.teamB?.score);
      if (!Number.isFinite(scoreA) || !Number.isFinite(scoreB)) return json({ error: "scores required" }, 400);

      const teamA = { teamId: null, members: [], score: scoreA };
      const teamB = { teamId: null, members: [], score: scoreB };

      if (gameType === "doubles" && ranked) {
        if (phase === "unranked") return json({ error: "Ranked matches cannot be phase=unranked" }, 400);

        const teamAId = String(body?.teamA?.teamId || "").trim();
        const teamBId = String(body?.teamB?.teamId || "").trim();
        if (!teamAId || !teamBId) return json({ error: "teamA.teamId and teamB.teamId required for ranked doubles" }, 400);

        const tA = state.teams[teamAId];
        const tB = state.teams[teamBId];
        if (!tA || !tB) return json({ error: "One or both teams not found" }, 404);

        teamA.teamId = teamAId;
        teamA.members = sortKeys((tA.members || []).map(keyName));

        teamB.teamId = teamBId;
        teamB.members = sortKeys((tB.members || []).map(keyName));

        if (teamA.members.length !== 2 || teamB.members.length !== 2) return json({ error: "Teams must have 2 members" }, 400);
      }

      if (gameType === "doubles" && !ranked) {
        if (phase !== "unranked") return json({ error: "Unranked doubles must use phase=unranked" }, 400);

        const aMembers = Array.isArray(body?.teamA?.members) ? body.teamA.members.map(keyName).filter(Boolean) : [];
        const bMembers = Array.isArray(body?.teamB?.members) ? body.teamB.members.map(keyName).filter(Boolean) : [];

        const aUniq = dedupe(aMembers);
        const bUniq = dedupe(bMembers);

        if (aUniq.length !== 2 || bUniq.length !== 2) {
          return json({ error: "Unranked doubles requires exactly 2 players per side" }, 400);
        }

        teamA.members = sortKeys(aUniq);
        teamB.members = sortKeys(bUniq);

        const okA = assertMembersExist(state, teamA.members);
        const okB = assertMembersExist(state, teamB.members);
        if (!okA.ok) return json({ error: okA.error }, 400);
        if (!okB.ok) return json({ error: okB.error }, 400);
      }

      if (gameType === "singles") {
        const aMembers = Array.isArray(body?.teamA?.members) ? body.teamA.members.map(keyName).filter(Boolean) : [];
        const bMembers = Array.isArray(body?.teamB?.members) ? body.teamB.members.map(keyName).filter(Boolean) : [];

        const aUniq = dedupe(aMembers);
        const bUniq = dedupe(bMembers);

        if (aUniq.length !== 1 || bUniq.length !== 1) return json({ error: "Singles requires exactly 1 player per side" }, 400);
        if (aUniq[0] === bUniq[0]) return json({ error: "Singles players must be different" }, 400);

        teamA.members = aUniq;
        teamB.members = bUniq;

        const okA = assertMembersExist(state, teamA.members);
        const okB = assertMembersExist(state, teamB.members);
        if (!okA.ok) return json({ error: okA.error }, 400);
        if (!okB.ok) return json({ error: okB.error }, 400);
      }

      const match = {
        id: crypto.randomUUID ? crypto.randomUUID() : `${Date.now()}-${Math.random()}`,
        seasonId,
        phase,
        ranked,
        gameType,
        dateTime: nowIso(),
        recordedBy: auth.player.name,
        recordedByKey: auth.playerKey,
        teamA,
        teamB,
        fingerprint: ""
      };

      match.fingerprint = await computeFingerprint(match);

      if (state.matches.some((m) => m.fingerprint && m.fingerprint === match.fingerprint)) {
        return json({ error: "Duplicate match detected (already logged recently)" }, 409);
      }

      state.matches.push(match);
      await writeState(state);

      return json({ ok: true, match });
    }

    // Matches: update (owner/admin). Keeps match type/season/recordedBy/dateTime unchanged.
    const putMatch = path.match(/^\/matches\/([^/]+)$/);
    if (request.method === "PUT" && putMatch) {
      const matchId = putMatch[1];
      const state = await readState();
      const auth = await requireAuth(state, request);
      if (!auth.ok) return json({ error: auth.error }, 401);

      const idx = state.matches.findIndex((m) => m.id === matchId);
      if (idx < 0) return json({ error: "Match not found" }, 404);

      const existing = state.matches[idx];
      const isOwner = existing.recordedByKey === auth.playerKey;
      const isAdmin = !!auth.player.isAdmin;
      if (!isOwner && !isAdmin) return json({ error: "Forbidden" }, 403);

      let body;
      try { body = await request.json(); } catch { return json({ error: "Invalid JSON" }, 400); }

      // Allow editing: scores always, and phase only for ranked doubles
      const scoreA = Number(body?.teamA?.score);
      const scoreB = Number(body?.teamB?.score);
      if (!Number.isFinite(scoreA) || !Number.isFinite(scoreB)) return json({ error: "scores required" }, 400);

      const next = structuredClone(existing);
      next.teamA.score = scoreA;
      next.teamB.score = scoreB;

      // phase edits: only for ranked doubles
      if (existing.gameType === "doubles" && existing.ranked === true) {
        const phase = String(body?.phase || existing.phase || "regular").trim().toLowerCase();
        if (!["preseason","regular","championship"].includes(phase)) {
          return json({ error: "Invalid phase (ranked must be preseason|regular|championship)" }, 400);
        }
        next.phase = phase;
      }

      // If caller included teamIds or members, accept them (but do not require).
      // This allows "no team select" edits, while still permitting corrections if needed.
      if (existing.gameType === "doubles" && existing.ranked === true) {
        const maybeAId = body?.teamA?.teamId ? String(body.teamA.teamId).trim() : null;
        const maybeBId = body?.teamB?.teamId ? String(body.teamB.teamId).trim() : null;

        if (maybeAId) {
          const tA = state.teams[maybeAId];
          if (!tA) return json({ error: "teamA team not found" }, 404);
          next.teamA.teamId = maybeAId;
          next.teamA.members = sortKeys((tA.members || []).map(keyName));
        }
        if (maybeBId) {
          const tB = state.teams[maybeBId];
          if (!tB) return json({ error: "teamB team not found" }, 404);
          next.teamB.teamId = maybeBId;
          next.teamB.members = sortKeys((tB.members || []).map(keyName));
        }
      }

      if (existing.gameType === "doubles" && existing.ranked === false) {
        // unranked doubles: optional members change if provided
        if (Array.isArray(body?.teamA?.members)) {
          const aUniq = dedupe(body.teamA.members.map(keyName).filter(Boolean));
          if (aUniq.length !== 2) return json({ error: "Unranked doubles requires 2 players for teamA" }, 400);
          const okA = assertMembersExist(state, aUniq);
          if (!okA.ok) return json({ error: okA.error }, 400);
          next.teamA.teamId = null;
          next.teamA.members = sortKeys(aUniq);
        }
        if (Array.isArray(body?.teamB?.members)) {
          const bUniq = dedupe(body.teamB.members.map(keyName).filter(Boolean));
          if (bUniq.length !== 2) return json({ error: "Unranked doubles requires 2 players for teamB" }, 400);
          const okB = assertMembersExist(state, bUniq);
          if (!okB.ok) return json({ error: okB.error }, 400);
          next.teamB.teamId = null;
          next.teamB.members = sortKeys(bUniq);
        }
        next.phase = "unranked";
        next.ranked = false;
      }

      if (existing.gameType === "singles") {
        // singles unranked only
        next.ranked = false;
        next.phase = "unranked";
        if (Array.isArray(body?.teamA?.members)) {
          const aUniq = dedupe(body.teamA.members.map(keyName).filter(Boolean));
          if (aUniq.length !== 1) return json({ error: "Singles requires 1 player for teamA" }, 400);
          const okA = assertMembersExist(state, aUniq);
          if (!okA.ok) return json({ error: okA.error }, 400);
          next.teamA.teamId = null;
          next.teamA.members = aUniq;
        }
        if (Array.isArray(body?.teamB?.members)) {
          const bUniq = dedupe(body.teamB.members.map(keyName).filter(Boolean));
          if (bUniq.length !== 1) return json({ error: "Singles requires 1 player for teamB" }, 400);
          const okB = assertMembersExist(state, bUniq);
          if (!okB.ok) return json({ error: okB.error }, 400);
          next.teamB.teamId = null;
          next.teamB.members = bUniq;
        }
      }

      // recompute fingerprint (keeps original dateTime bucket behavior)
      next.fingerprint = await computeFingerprint(next);

      if (state.matches.some((m) => m.id !== matchId && m.fingerprint && m.fingerprint === next.fingerprint)) {
        return json({ error: "Duplicate match detected (already logged recently)" }, 409);
      }

      state.matches[idx] = next;
      await writeState(state);
      return json({ ok: true });
    }

    // Matches: delete (owner/admin)
    const delMatch = path.match(/^\/matches\/([^/]+)$/);
    if (request.method === "DELETE" && delMatch) {
      const matchId = delMatch[1];
      const state = await readState();
      const auth = await requireAuth(state, request);
      if (!auth.ok) return json({ error: auth.error }, 401);

      const existing = state.matches.find((m) => m.id === matchId);
      if (!existing) return json({ error: "Match not found" }, 404);

      const isOwner = existing.recordedByKey === auth.playerKey;
      const isAdmin = !!auth.player.isAdmin;
      if (!isOwner && !isAdmin) return json({ error: "Forbidden" }, 403);

      state.matches = state.matches.filter((m) => m.id !== matchId);
      await writeState(state);
      return json({ ok: true });
    }

    // Old endpoint support: block POST / (prevent overwrite)
    if (request.method === "POST" && path === "/") {
      return json({ error: "This endpoint is disabled. Use /matches with auth." }, 405);
    }

    return text("Not found", 404);
  }
};
